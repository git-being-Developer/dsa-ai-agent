package scrapperAI

import (
	"context"
	"dsa-ai-agent/config"
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/openai/openai-go"
	"github.com/openai/openai-go/option"
	"github.com/openai/openai-go/packages/param"
)

type ScrapperAI interface {
	connectToAgent() error
	initializePrompt()
	generateBoilerPlateCode() error
	saveCodeToFile() error
	Run() error
}

type OpenAIAgent struct {
	Lang          string // e.g., "python", "go", "cpp"
	client        openai.Client
	QuestionTitle string // e.g., "Two Sum"
	QuestionSlug  string // e.g., "two-sum" - for the filename
	questionDesc  string // The full problem description from the API
	prompt        string // The fully constructed prompt for the AI
	boilerPlate   string // The final code generated by the AI
}

func NewAIAgent(lang, title, description string) *OpenAIAgent {
	re := regexp.MustCompile(`\s+`)
	slug := strings.ToLower(re.ReplaceAllString(title, "-"))

	return &OpenAIAgent{
		Lang:          lang,
		QuestionTitle: title,
		QuestionSlug:  slug,
		questionDesc:  description,
	}
}
func (o *OpenAIAgent) GetQuestionTitle() string { return o.QuestionTitle }
func (o *OpenAIAgent) GetQuestionSlug() string  { return o.QuestionSlug }
func (o *OpenAIAgent) GetQuestionDesc() string  { return o.questionDesc }
func (o *OpenAIAgent) GetLang() string          { return o.Lang }
func (o *OpenAIAgent) connectToAgent() error {
	client := openai.NewClient(
		option.WithAPIKey(config.AppConfig.OPEN_AI_API),
	)
	o.client = client
	fmt.Println("âœ… AI Agent connected.")
	return nil
}

func (o *OpenAIAgent) initializePrompt() {
	o.prompt = fmt.Sprintf(`
You are a LeetCode expert assistant. Your sole purpose is to generate the precise boilerplate code for a given programming problem. User will implement the function but other parts should be there as well so that user can run that against a few test cases.

**Instructions:**
1. Read the problem title.
2. Generate the function signature and boilerplate that matches the problem's requirements for the specified language.
3. The output must be ONLY the code. Do not include any explanation, introductory text, or markdown formatting like backticks.
4.The funtion description should be just above the function signature in comments

**Constraints for the Code:**
* Language: %s
* Wrap the function inside a 'class Solution:' for Python, or a 'struct Solution' with methods for Go/C++.
* Use the exact function and parameter names implied by the problem description.
* Include all necessary type hints for Python, or correct types for Go/C++.
* The function body should contain only the 'pass' keyword for Python or be empty for Go/C++.

---
**Problem Title:**
%s
---
**Boilerplate Code:**`, o.Lang, o.QuestionTitle)

	fmt.Println("âœ… AI prompt initialized.")
}
func (o *OpenAIAgent) generateBoilerPlateCode() error {
	fmt.Println("ðŸ¤– Sending request to AI... (this may take a moment)")
	resp, err := o.client.Chat.Completions.New(context.TODO(), openai.ChatCompletionNewParams{
		Messages: []openai.ChatCompletionMessageParamUnion{
			openai.UserMessage(o.prompt),
		},
		Model:       openai.ChatModelGPT4,
		Temperature: param.NewOpt(0.2),
	})
	if err != nil {
		return fmt.Errorf("chat completion failed: %w", err)
	}
	if len(resp.Choices) == 0 {
		return errors.New("no choices returned from OpenAI")
	}

	// We extract the AI's message content and store it.
	o.boilerPlate = resp.Choices[0].Message.Content
	fmt.Println("âœ… Boilerplate code generated.")
	return nil
}

func (o *OpenAIAgent) saveCodeToFile() error {
	// Determine the correct file extension based on the language.
	var extension string
	switch o.Lang {
	case "python":
		extension = ".py"
	case "go":
		extension = ".go"
	case "cpp":
		extension = ".cpp"
	case "java":
		extension = ".java"
	default:
		return fmt.Errorf("unsupported language: %s", o.Lang)
	}

	// Create a clean file path. e.g., "problems/two-sum.py"
	dir := "problems"
	fileName := o.QuestionSlug + extension
	filePath := filepath.Join(dir, fileName)

	// Create the 'problems' directory if it doesn't exist.
	// os.MkdirAll is safe to call even if the directory already exists.
	if err := os.MkdirAll(dir, os.ModePerm); err != nil {
		return fmt.Errorf("failed to create directory: %w", err)
	}

	code := strings.SplitN(o.boilerPlate, "\n", 2)
	o.boilerPlate = code[1]
	o.boilerPlate = strings.Trim(o.boilerPlate, "`")
	err := os.WriteFile(filePath, []byte(o.boilerPlate), 0644)
	if err != nil {
		return fmt.Errorf("failed to write to file: %w", err)
	}

	fmt.Printf("âœ… Code saved successfully to %s\n", filePath)
	return nil
}

func (o *OpenAIAgent) Run() error {
	if err := o.connectToAgent(); err != nil {
		return err
	}
	o.initializePrompt()
	if err := o.generateBoilerPlateCode(); err != nil {
		return err
	}
	if err := o.saveCodeToFile(); err != nil {
		return err
	}
	return nil
}
